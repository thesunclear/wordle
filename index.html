<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Wordle Helper — jaehong.kim</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Favicons & PWA -->
  <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png" />
  <link rel="manifest" href="./site.webmanifest" />
  <meta name="theme-color" content="#0f1115" />

  <style>
    *,*::before,*::after{box-sizing:border-box}

    :root{
      /* Dark (default) */
      --bg:#0f1115;--fg:#e6ebf2;--sub:#aab3c2;--muted:#667085;
      --card:#161a22;--accent:#7aa2f7;--good:#22c55e;--bad:#ef4444;
      --warn:#f59e0b;--btn:#222938;--btnHover:#2b3550;
      --border:#212836;--input:#0b0e14;
      /* Background tuning for DARK */
      --overlay: rgba(10,12,16,.35);
      --bg-bright: .75;
      --bg-blur: 1px;
    }
    body.light{
      /* Light */
      --bg:#f8fafc;--fg:#0f172a;--sub:#334155;--muted:#64748b;
      --card:#ffffff;--accent:#3b82f6;--good:#16a34a;--bad:#dc2626;
      --warn:#d97706;--btn:#e2e8f0;--btnHover:#cbd5e1;
      --border:#dbe1ea;--input:#f1f5f9;
    }

    html,body{height:100%}
    html,body{margin:0;padding:0;background:transparent;color:var(--fg);font:14px/1.5 system-ui,Segoe UI,Inter,Roboto,Arial}
    /* Light: disable background image */
    body.light{ background: var(--bg); }
    body.light::before, body.light::after{ content:none !important; }

    /* Dark: background image visible */
    body::before{
      content:""; position:fixed; inset:0;
      background:url('./background.jpg') center/512px repeat;
      filter: brightness(var(--bg-bright)) saturate(.95) blur(var(--bg-blur));
      z-index:-2; will-change:transform;
    }
    body::after{ content:""; position:fixed; inset:0; background:var(--overlay); z-index:-1; }

    .wrap{max-width:1000px;margin:0 auto;padding:20px}
    h1{font-size:20px;margin:0}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:14px;min-width:0;box-shadow:0 6px 18px rgba(0,0,0,.15)}
    .btn{background:var(--btn);border:1px solid var(--border);color:var(--fg);border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn[disabled]{opacity:.6;cursor:not-allowed}
    .btn:hover{background:var(--btnHover)}
    input[type="file"]{display:none}
    .filelabel{display:inline-block}
    .tag{color:var(--sub);font-size:12px;margin-left:6px}
    .bar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .search{flex:1;min-width:220px;max-width:700px}
    .search input{width:100%;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:var(--input);color:var(--fg)}

    /* Key grids */
    .grid{display:grid;grid-template-columns:repeat(13,minmax(28px,1fr));gap:6px}
    .k{display:flex;align-items:center;justify-content:center;border-radius:8px;border:1px solid var(--border);background:var(--input);height:34px;cursor:pointer;user-select:none}
    .k.inc{background:rgba(34,197,94,.18);border-color:#1f9b56}
    .k.exc{background:rgba(239,68,68,.20);border-color:#a12828}

    /* Tabs */
    .tabs{display:grid;grid-template-columns:repeat(5, 1fr);gap:8px}
    .tab{padding:6px 10px;text-align:center;border-radius:10px;border:1px solid var(--border);background:var(--input);color:var(--fg);cursor:pointer;white-space:nowrap;min-width:0}
    .tab.active{outline:2px solid var(--accent)}

    /* List */
    .list{max-height:60vh;overflow:auto;border:1px solid var(--border);border-radius:12px}
    .list ul{list-style:none;margin:0;padding:0}
    .list li{padding:10px 12px;border-bottom:1px solid var(--border);font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .list li:last-child{border-bottom:none}
    small{color:var(--muted)} .hint{color:var(--sub)}
    .counter{font-size:18px;font-weight:700;margin:14px 2px 6px 2px;color:var(--fg)}
    .counter small{font-weight:500;color:var(--sub)}
    .header-row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px}
    .header-row .btn{padding:6px 10px}

    /* Help */
    .help{margin-top:18px;color:var(--sub);font-size:13px;line-height:1.45}
    .help ul{margin:6px 0 0 18px;padding:0}
    .help li{margin-bottom:4px}
    .help code{background:var(--input);border-radius:5px;padding:1px 4px;font-family:ui-monospace,monospace}

    /* Suggestion table */
    table{width:100%;border-collapse:collapse}
    thead th{font-weight:600;text-align:left;border-bottom:1px solid var(--border);padding:8px}
    tbody td{padding:8px;border-bottom:1px solid var(--border);font-family:ui-monospace,monospace}
    .mono{font-family:ui-monospace,monospace}

    /* Recommender controls */
    .ctl{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .ctl label{font-size:13px;color:var(--sub);display:flex;gap:6px;align-items:center}
    .ctl input[type="number"]{width:86px;padding:6px;border-radius:8px;border:1px solid var(--border);background:var(--input);color:var(--fg)}
    .ctl select{padding:6px;border-radius:8px;border:1px solid var(--border);background:var(--input);color:var(--fg)}
    .progress{height:6px;background:var(--input);border:1px solid var(--border);border-radius:999px;overflow:hidden}
    .barin{height:100%;background:var(--accent);width:0%}

    /* Responsive */
    @media(max-width:1024px){#gInc,#gExc,#pInc,#pExc{grid-template-columns:repeat(12,minmax(28px,1fr))}}
    @media(max-width:960px){#gInc,#gExc,#pInc,#pExc{grid-template-columns:repeat(11,minmax(28px,1fr))}}
    @media(max-width:900px){#gInc,#gExc,#pInc,#pExc{grid-template-columns:repeat(10,minmax(28px,1fr))}}
    @media(max-width:840px){#gInc,#gExc,#pInc,#pExc{grid-template-columns:repeat(9,minmax(28px,1fr))}}
    @media(max-width:720px){
      body::before{filter:brightness(var(--bg-bright)) saturate(.95) blur(.8px)}
      .search{flex-basis:100%;max-width:100%}
      #gInc,#gExc,#pInc,#pExc{grid-template-columns:repeat(9,minmax(26px,1fr));gap:5px}
      #gInc .k,#gExc .k,#pInc .k,#pExc .k{height:32px}
      .counter{font-size:16px;margin:12px 2px 6px}
      .tabs{gap:6px}.tab{padding:5px 8px;font-size:13px}
    }
    @media(max-width:480px){.tab .label{display:none}.tab{padding:5px 6px;font-size:13px}}
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Header -->
    <div class="header-row">
      <h1>Wordle Helper <span class="tag">wordle.jaehong.kim</span></h1>
      <button class="btn" id="modeToggle" title="Toggle Dark/Light">🌙 Dark</button>
    </div>

    <!-- Top controls -->
    <div class="card" style="margin-bottom:12px">
      <div class="bar">
        <label class="filelabel">
          <input id="fileInput" type="file" accept=".csv,.txt" />
        <button class="btn" id="chooseFileBtn">Upload Custom List (CSV)</button>
        </label>
        <button class="btn" id="use2315">Use 2315 Words (Default)</button>
        <button class="btn" id="use3200">Use 3200 Words</button>
        <button class="btn" id="use14855">Use 14855 Words</button>
      </div>
      <div class="bar" style="margin-top:10px">
        <div class="search">
          <input id="searchBox" placeholder="Search (use ?, *, [AEIOU], &, |, ( ) — see help below)" / style="text-transform:uppercase; text-transform:uppercase;">
        </div>
        <button class="btn" id="clearAll">Clear Filters</button>
      </div>
    </div>

    <!-- Global include/exclude -->
    <div class="row">
      <div class="card" style="flex:1;min-width:320px">
        <div style="margin-bottom:8px"><strong>Global Include</strong></div>
        <div class="grid" id="gInc"></div>
      </div>
      <div class="card" style="flex:1;min-width:320px">
        <div style="margin-bottom:8px"><strong>Global Exclude</strong></div>
        <div class="grid" id="gExc"></div>
      </div>
    </div>

    <!-- Position include/exclude -->
    <div class="card" style="margin-top:12px">
      <div class="tabs" id="tabs"></div>
      <div class="row" style="margin-top:10px">
        <div class="card" style="flex:1;min-width:280px">
          <div style="margin-bottom:8px"><strong>Position Include</strong></div>
          <div class="grid" id="pInc"></div>
        </div>
        <div class="card" style="flex:1;min-width:280px">
          <div style="margin-bottom:8px"><strong>Position Exclude</strong></div>
          <div class="grid" id="pExc"></div>
        </div>
      </div>
    </div>

    <!-- Counter -->
    <div class="counter"><span id="count">0</span> <small>candidates</small></div>

    <!-- List -->
    <div class="card list" style="margin-top:6px">
      <ul id="words"></ul>
    </div>

    <!-- Recommender -->
    <div class="card" style="margin-top:12px">
      <div class="bar" style="justify-content:space-between">
        <div><strong>Next-Guess Recommender</strong> <span class="tag">(Exact for small sets · Fast entropy for large sets)</span></div>
        <div class="bar">
          <button class="btn" id="suggestExact">Suggest (Exact E[steps])</button>
          <button class="btn" id="suggestFast">Suggest (Fast)</button>
          <button class="btn" id="resetSuggest" title="Clear results and progress">Reset</button>
        </div>
      </div>

      <!-- Controls: row 1 -->
      <div class="ctl" style="margin-top:10px">
        <label title="Enforce feedback consistency (Wordle Hard Mode rules)">Hard Mode <input type="checkbox" id="hardMode" />
        </label>
        <label title="Guess pool used when Hard Mode is OFF">
          Pool
          <select id="poolSelect">
            <option value="current" selected>Current List</option>
            <option value="2315">2315 Words</option>
            <option value="3200">3200 Words</option>
            <option value="14855">14855 Words</option>
          </select>
        </label>
      </div>

      <!-- Controls: row 2 -->
      <div class="ctl" style="margin-top:6px">
        <label title="Max |S| for Exact recursion; above this use Fast">
          Exact Thr
          <input type="number" id="exactThreshold" value="200" min="5" max="2315" />
        </label>
        <label title="When using external guesses in Exact, add top-N (by entropy)">
          Max Pool
          <input type="number" id="exactMaxPool" value="200" min="0" max="2315" />
        </label>
        <label title="Fast mode: limit of guesses evaluated (higher = slower, more precise)">
          Fast Evals
          <input type="number" id="fastMax" value="2315" min="50" max="20000" />
        </label>
        <button class="btn" id="stopBtn" disabled>Stop</button>
      </div>

      <div class="hint" id="modeNote" style="margin-top:4px">
        Hard Mode ON → guess only from candidates. Hard Mode OFF → guess from (candidates + selected Pool).
      </div>

      <!-- Progress + status -->
      <div class="progress" style="margin-top:10px"><div id="pbar" class="barin"></div></div>
      <div id="suggestStatus" class="hint" style="margin-top:8px"></div>

      <!-- Table -->
      <div style="overflow:auto;margin-top:8px">
        <table>
          <thead>
            <tr>
              <th>Word</th>
              <th>E[steps]</th>
              <th>Entropy</th>
              <th>E[cands]</th>
              <th>Max Bucket</th>
            </tr>
          </thead>
          <tbody id="suggestTable"></tbody>
        </table>
      </div>
    </div>
    
    <!-- Analyze Word -->
    <div class="card" id="analyzeCard" style="margin-top:12px">
      <div class="bar" style="justify-content:space-between; gap:8px;">
        <div><strong>Analyze Word</strong> <span class="tag">(Metrics with respect to current candidates S)</span></div>
        <div class="bar" style="gap:6px;">
          <input id="analyzeInput" maxlength="5" placeholder="Enter a 5-letter word" style="text-transform:uppercase;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:var(--input);color:var(--fg)" />
          <button class="btn" id="analyzeBtn">Analyze</button>
        </div>
      </div>
      <div style="overflow:auto;margin-top:10px">
        <table>
          <thead><tr><th>Word</th><th>E[steps]</th><th>Entropy</th><th>E[cands]</th><th>Max Bucket</th></tr></thead>
          <tbody id="analyzeTable"></tbody>
        </table>
      </div>
    </div>
<!-- Search Help -->
    <div class="help">
      <strong>Search Help</strong>
      <ul>
        <li><b>?</b>: exactly one letter (e.g., <code>A?E</code> → <i>ACE, APE, ARE</i>)</li>
        <li><b>*</b>: zero or more letters (e.g., <code>A*A</code> → <i>ARENA, ALPHA, AMAZE</i>)</li>
        <li><b>[AEIOU]</b>: any one listed; <b>[^AEIOU]</b>: not these (e.g., <code>[^AEIOU]ATE</code> → <i>SLATE, CRATE</i>)</li>
        <li><b>&</b>: AND; <b>|</b>: OR (AND has higher precedence)</li>
        <li><b>( )</b>: group terms (e.g., <code>(ING & R) | (A?E & N)</code>)</li>
      </ul>

<!-- Keyboard hints -->
    <div style="margin-top:10px">
      <small>
        Letter: Global Include · Alt+Letter: Global Exclude · Shift+Letter: Position Include · Ctrl+Letter: Position Exclude · 1–5: Switch Tab · /: Search · `: Theme
      </small>
    </div>
	</div>
  </div>

  <script>
    /* ===== Utilities & State ===== */
    const byId=id=>document.getElementById(id);
    const ALPHA=Array.from({length:26},(_,i)=>String.fromCharCode(65+i));
    const state={
      all:[], filtered:[], search:'',
      searchTester:null,
      globalInclude:new Set(), globalExclude:new Set(),
      pos:Array.from({length:5},()=>({include:new Set(),exclude:new Set()})),
      activePos:0,
      base2315:[], base3200:[], base14855:[],
      cancel:false
    };

    /* ===== Theme ===== */
    (function(){
      const s=localStorage.getItem('wf-theme');
      if(s==='light')document.body.classList.add('light');
      updateThemeBtn(); byId('modeToggle').onclick=toggleTheme;
    })();
    function toggleTheme(){
      document.body.classList.toggle('light');
      localStorage.setItem('wf-theme',document.body.classList.contains('light')?'light':'dark');
      updateThemeBtn();
    }
    function updateThemeBtn(){
      byId('modeToggle').textContent=document.body.classList.contains('light')?'☀️ Light':'🌙 Dark';
    }

    /* ===== CSV parsing & loading ===== */
    function parseWordsFromCsvText(t){
      const lines=t.split(/\r?\n/);const words=[];const seen=new Set();
      for(const raw of lines){
        const line=raw.trim(); if(!line) continue;
        const cells=line.split(/,|\s+/);
        for(let c of cells){
          c=(c||'').trim().toLowerCase();
          if(/^[a-z]{5}$/.test(c)&&!seen.has(c)){ seen.add(c); words.push(c); }
        }
      }
      return words;
    }
    async function fetchCsv(name){
      const res=await fetch(`./${name}`,{cache:'no-store'});
      if(!res.ok) throw new Error('fetch failed: '+name);
      return parseWordsFromCsvText(await res.text());
    }
    async function loadCsvFile(name){
      try{
        lockUI(true);
        const words=await fetchCsv(name);
        loadWordsFromArray(words);
      }catch(e){ alert('Error loading '+name+': '+e.message); }
      finally{ lockUI(false); }
    }

    /* ===== Keyboards & Tabs ===== */
    function buildKeyboard(container,kind){
      container.innerHTML='';
      for(const ch of ALPHA){
        const d=document.createElement('div');
        d.className='k'; d.textContent=ch; d.dataset.ch=ch.toLowerCase();
        d.onclick=()=>{
          if(kind==='gInc')toggle(state.globalInclude,state.globalExclude,d.dataset.ch);
          else if(kind==='gExc')toggle(state.globalExclude,state.globalInclude,d.dataset.ch);
          else if(kind==='pInc')toggle(state.pos[state.activePos].include,state.pos[state.activePos].exclude,d.dataset.ch);
          else toggle(state.pos[state.activePos].exclude,state.pos[state.activePos].include,d.dataset.ch);
          refresh(); apply();
        };
        container.appendChild(d);
      }
    }
    function toggle(primary,secondary,ch){
      if(primary.has(ch)) primary.delete(ch); else { primary.add(ch); secondary.delete(ch); }
    }
    function refresh(){
      const gI=byId('gInc').children, gE=byId('gExc').children,
            pI=byId('pInc').children, pE=byId('pExc').children;
      for(const e of gI) e.classList.toggle('inc',state.globalInclude.has(e.dataset.ch));
      for(const e of gE) e.classList.toggle('exc',state.globalExclude.has(e.dataset.ch));
      for(const e of pI) e.classList.toggle('inc',state.pos[state.activePos].include.has(e.dataset.ch));
      for(const e of pE) e.classList.toggle('exc',state.pos[state.activePos].exclude.has(e.dataset.ch));
      for(const t of byId('tabs').children) t.classList.toggle('active',Number(t.dataset.idx)===state.activePos);
    }
    function renderTabs(){
      const tabs=byId('tabs'); tabs.innerHTML='';
      for(let i=0;i<5;i++){
        const b=document.createElement('button');
        b.className='tab'+(i===state.activePos?' active':'');
        b.innerHTML='<span class="label">Pos </span><span class="num">'+(i+1)+'</span>';
        b.dataset.idx=i; b.onclick=()=>{ state.activePos=i; refresh(); };
        tabs.appendChild(b);
      }
    }

    /* ===== Search expression ===== */
    function sanitizeClassContent(s){const x=s.toLowerCase().replace(/\s+/g,''); if(!/^[a-z\-\^]*$/.test(x)) return null; return x;}
    function escapeRe(s){return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');}
    function buildRegexFromMiniPattern(q){
      let reStr=''; for(let i=0;i<q.length;i++){ const ch=q[i];
        if(ch==='*'){ let j=i; while(j<q.length&&q[j]==='*') j++; reStr+='[a-z]*'; i=j-1; }
        else if(ch==='?'){ reStr+='[a-z]'; }
        else if(ch==='['){ let j=i+1; while(j<q.length&&q[j]!==']') j++;
          if(j<q.length){ const s=q.slice(i+1,j); const ok=sanitizeClassContent(s); if(ok!==null){reStr+=`[${ok}]`; i=j; } else reStr+='\\['; }
          else reStr+='\\[';
        } else if(ch===' '){ /* ignore */ }
        else if(/[a-z]/.test(ch)){ reStr+=ch; }
        else reStr+=escapeRe(ch);
      }
      return new RegExp(reStr);
    }
    function tokenize(expr){
      const s=(expr||'').toLowerCase(); const out=[]; let i=0; const isOp=c=>c==='|'||c==='&';
      while(i<s.length){
        const c=s[i]; if(c===' '){i++;continue;}
        if(c==='('||c===')'||isOp(c)){ out.push({type:c}); i++; continue; }
        let buf=''; while(i<s.length){ const ch=s[i];
          if(ch==='('||ch===')'||isOp(ch)||ch===' ') break;
          if(ch==='['){ let j=i+1; while(j<s.length&&s[j]!==']') j++; if(j<s.length){ buf+=s.slice(i,j+1); i=j+1; continue; } else { buf+='['; i++; continue; } }
          buf+=ch; i++;
        } out.push({type:'pat',value:buf});
      } return out;
    }
    function toRPN(tokens){
      const out=[], st=[]; const prec=t=>t.type==='&'?2:(t.type==='|'?1:0); const isOp=t=>t.type==='|'||t.type==='&';
      for(const t of tokens){
        if(t.type==='pat') out.push(t);
        else if(isOp(t)){ while(st.length){ const top=st[st.length-1]; if(isOp(top)&&prec(top)>=prec(t)) out.push(st.pop()); else break; } st.push(t); }
        else if(t.type==='(') st.push(t);
        else if(t.type===')'){ while(st.length&&st[st.length-1].type!=='(') out.push(st.pop()); if(st.length&&st[st.length-1].type==='(') st.pop(); }
      }
      while(st.length){ const x=st.pop(); if(x.type!=='('&&x.type!==')') out.push(x); } return out;
    }
    function buildTesterFromRPN(rpn){
      const st=[]; for(const t of rpn){
        if(t.type==='pat'){ const re=buildRegexFromMiniPattern(t.value); st.push(w=>re.test(w)); }
        else if(t.type==='&'||t.type==='|'){ const b=st.pop(), a=st.pop(); if(!a||!b) return null; st.push(t.type==='&'?(w)=>a(w)&&b(w):(w)=>a(w)||b(w)); }
      }
      return st.length===1?st[0]:null;
    }
    function buildSearchTester(expr){
       const toks=tokenize(expr); if(!toks.some(t=>t.type==='pat')) return null;
       const rpn=toRPN(toks); const tester=buildTesterFromRPN(rpn); return tester||null;
    }

    /* ===== Filter & list ===== */
    function apply(){
      const out=[]; const gi=state.globalInclude, ge=state.globalExclude; const tester=state.searchTester;
      WORDS: for(const w of state.all){
        if(tester && !tester(w)) continue;
        for(const ch of ge) if(w.includes(ch)) continue WORDS;
        for(const ch of gi) if(!w.includes(ch)) continue WORDS;
        for(let i=0;i<5;i++){
          const need=state.pos[i].include, ban=state.pos[i].exclude, c=w[i];
          if(need.size>0 && !need.has(c)) continue WORDS;
          if(ban.has(c)) continue WORDS;
        }
        out.push(w);
      }
      state.filtered=out; renderList();
    }
    function renderList(){
      const ul=byId('words'); ul.innerHTML='';
      for(const w of state.filtered){ const li=document.createElement('li'); li.textContent=w.toUpperCase(); ul.appendChild(li); }
      byId('count').textContent=state.filtered.length;
    }
    function loadWordsFromArray(a){
      const seen=new Set(); state.all=a.filter(w=>/^[a-z]{5}$/.test(w)&&!seen.has(w)&&seen.add(w)).sort(); apply();
    }

    /* ===== Wordle feedback ===== */
    function pattern(guess, answer){
      const g=[...guess], a=[...answer]; const res=Array(5).fill('0'); const cnt={};
      for(let i=0;i<5;i++){ if(a[i]===g[i]){ res[i]='2'; } else { cnt[a[i]]=(cnt[a[i]]||0)+1; } }
      for(let i=0;i<5;i++){ if(res[i]==='2') continue; const ch=g[i]; if(cnt[ch]>0){ res[i]='1'; cnt[ch]--; } }
      return res.join('');
    }
    function partitionByPattern(S, guess){
      const map=new Map();
      for(const ans of S){
        const p=pattern(guess, ans);
        let arr=map.get(p); if(!arr){ arr=[]; map.set(p,arr); }
        arr.push(ans);
      }
      return map;
    }
    function entropyAndExpectedSize(S, guess){
      const parts=partitionByPattern(S, guess); const n=S.length; let H=0, exp=0, maxb=0;
      for(const arr of parts.values()){
        const p=arr.length/n; H += -p*Math.log2(p); exp += p*arr.length; if(arr.length>maxb) maxb=arr.length;
      }
      return {entropy:H, expected:exp, maxBucket:maxb};
    }

	/* ===== Exact Esteps One Lookahead function ===== */
  function exactEstepsOneLookahead(guess, set){
    const part = partitionByPattern(guess, set);
    const N = set.length;
    let est = 0;
    for (const [pat, subset] of part.entries()){
      const m = subset.length; const p = m/N;
      if (pat === '22222'){ est += p * 1; }  // No extra steps for exact match
      else {
        let best = Infinity;
        for (const g2 of subset){
          const part2 = partitionByPattern(g2, subset);
          let e2 = 0;
          for (const [pat2, subset2] of part2.entries()){
            const m2 = subset2.length; const p2 = m2/subset.length;
            if (pat2 === '22222') e2 += p2 * 1;  // Exact match adds 0 steps
            else {
              const expLeaf = (m2===1) ? 1 : 2; // If subset is single, 1 step; else, 2 steps
              e2 += p2 * (1 + expLeaf); // 1 for the current guess, plus expected leaf steps
            }
          }
          if (e2 < best) best = e2;
        }
        est += p * (1 + best);
      }
    }
    return est;
  }

	/* ===== Exact DP (GREEN handled) ===== */
	const memo = new Map();
	function keyOf(S) { return S.join(','); }

	// Modified exactEsteps function using exactEstepsOneLookahead
	function exactEsteps(S) {
		const n = S.length;
		if (n <= 1) return 1;
		const k = keyOf(S);
		if (memo.has(k)) return memo.get(k);

	let best = Infinity;
  
	// Iterate over all guesses
	for (const g of S) {
		const parts = partitionByPattern(S, g);
		let exp = 0; // Start with 0 for the expected steps

		// For each pattern and its corresponding subset
		for (const [pat, arr] of parts.entries()) {
			if (pat === '22222') continue; // GREEN adds 0 extra steps
			const p = arr.length / n;

			// Use the exactEstepsOneLookahead function for more accurate calculation
			exp += p * exactEstepsOneLookahead(g, arr); // More accurate E[steps] calculation
		}

		if (state.cancel || exp >= best) {
			exp = Infinity;
			break;
		}

		if (exp < best) best = exp;
		if (state.cancel) break;
	}

	memo.set(k, best);
	return best;
	}

    /* ===== External pools (lazy load) ===== */
    async function ensurePoolLoaded(which){
      if(which==='2315' && !state.base2315.length){ state.base2315 = await fetchCsv('wordle_solutions_2315.csv'); }
      if(which==='3200' && !state.base3200.length){ state.base3200 = await fetchCsv('wordle_solutions_3200.csv'); }
      if(which==='14855'&& !state.base14855.length){ state.base14855= await fetchCsv('wordle_solutions_14855.csv'); }
    }
    async function getExternalPool(){
      const sel=byId('poolSelect').value;
      if(sel==='current') return state.all;        // current loaded list
      await ensurePoolLoaded(sel);
      if(sel==='2315')  return state.base2315.length? state.base2315 : state.all;
      if(sel==='3200')  return state.base3200.length? state.base3200 : state.all;
      if(sel==='14855') return state.base14855.length? state.base14855: state.all;
      return state.all;
    }

    /* ===== Recommenders ===== */
    function lockUI(yes){
      document.querySelectorAll('.btn').forEach(b=>{ if(b.id!=='stopBtn') b.disabled=yes; });
      byId('stopBtn').disabled = !yes;
    }
    function setProgress(p){ byId('pbar').style.width = Math.max(0,Math.min(100,p))+'%'; }

    function resetSuggestions(){
      byId('suggestTable').innerHTML='';
      byId('suggestStatus').textContent='';
      setProgress(0);
      state.cancel=false;
      memo.clear();
    }

    async function buildGuessPool(S, mode){
      const hard = byId('hardMode').checked;
      if(hard) return S; // Hard Mode ON → restrict to S only

      // Hard Mode OFF → use selected pool (Current/2315/3200/14855)
      const ext = await getExternalPool();

      if(mode==='fast'){
        // union S and external; keep order stable
        const set=new Set(S);
        const out=[...S];
        for(const w of ext){ if(!set.has(w)) out.push(w); }
        return out;
      } else {
        // exact: prefilter external by entropy; take top N (Max Pool)
        const maxN = Math.max(0, Number(byId('exactMaxPool').value) || 0);
        if(maxN===0) return S;
        const baseSet = new Set(S);
        const scored=[];
        const nEval = Math.min(ext.length, 1000);
        const step = Math.max(1, Math.floor(ext.length / Math.max(1,nEval)));
        for(let i=0;i<ext.length;i+=step){
          const g=ext[i];
          if(baseSet.has(g)) continue;
          const met=entropyAndExpectedSize(S,g);
          scored.push({g, score:met.entropy, expected:met.expected});
        }
        scored.sort((a,b)=> (b.score - a.score) || (a.expected - b.expected));
        const top = scored.slice(0, maxN).map(x=>x.g);
        return [...S, ...top];
      }
    }

    async function suggestFast(){
      const S=[...state.filtered]; const n=S.length;
      const tb=byId('suggestTable'), status=byId('suggestStatus');
      tb.innerHTML=''; setProgress(0); state.cancel=false;
      if(n===0){ status.textContent='No candidates.'; return; }
      const fmax = Number(byId('fastMax').value)||2315;
      lockUI(true); status.textContent = `Fast on ${n} candidates…`;
      await new Promise(r=>setTimeout(r,10));

      const pool = await buildGuessPool(S, 'fast');
      const rows=[]; let evaluated=0;
      const limit = Math.min(fmax, pool.length);
      for(let i=0;i<limit;i++){
        if(state.cancel) break;
        const g=pool[i];
        const met=entropyAndExpectedSize(S,g);
        rows.push({word:g, entropy:met.entropy, expected:met.expected, maxBucket:met.maxBucket, esteps:NaN});
        evaluated++;
        if((i&7)===0){ setProgress(100*evaluated/limit); await new Promise(r=>setTimeout(r,0)); }
      }
      rows.sort((a,b)=> (b.entropy - a.entropy) || (a.expected - b.expected) || (a.maxBucket - b.maxBucket));
      renderSuggestRows(rows, `Fast (evaluated ${evaluated}/${limit})`);
      lockUI(false); setProgress(100);
    }

	/* ===== Suggest Exact function ===== */
	async function suggestExact(){
		const S = [...state.filtered]; 
		const n = S.length;
		const tb = byId('suggestTable'), status = byId('suggestStatus');
		tb.innerHTML = ''; setProgress(0); state.cancel = false; memo.clear();

		if (n === 0) { 
			status.textContent = 'No candidates.'; 
			return; 
		}

		const thr = Number(byId('exactThreshold').value) || 200;
		if (n > thr) {
			status.textContent = `|S|=${n} > threshold ${thr}. Switching to Fast.`;
			await suggestFast(); 
			return;
		}

	lockUI(true);
	status.textContent = `Exact E[steps] on ${n} candidates…`;
	await new Promise(r => setTimeout(r, 10));

	const pool = await buildGuessPool(S, 'exact');
	const rows = []; 
	let evaluated = 0;
	const total = pool.length;

	for (let i = 0; i < pool.length; i++) {
		if (state.cancel) break;
    
		const g = pool[i];
		const parts = partitionByPattern(S, g); 
		let exp = 0;  // Start with 0 for the expected steps

		// Iterate over each pattern and its corresponding subset
		for (const [pat, arr] of parts.entries()) {
			if (pat === '22222') continue;  // GREEN adds 0 extra steps
			const p = arr.length / n;
      
			// Use the exactEstepsOneLookahead function for more accurate calculation
			exp += p * exactEstepsOneLookahead(g, arr);  // More accurate E[steps] calculation
			if (state.cancel) break;
		}

		const met = entropyAndExpectedSize(S, g);
		rows.push({ word: g, esteps: exp, entropy: met.entropy, expected: met.expected, maxBucket: met.maxBucket });
		evaluated++;

		// Update progress
		if ((i & 3) === 0) {
			setProgress(100 * evaluated / total); 
			await new Promise(r => setTimeout(r, 0));
		}
	}

	// Sort by E[steps], then entropy and expected size
	rows.sort((a, b) => (a.esteps - b.esteps) || (b.entropy - a.entropy) || (a.expected - b.expected));
  
	// Render results to the table
	renderSuggestRows(rows, `Exact (evaluated ${evaluated}/${total})`);
  
	lockUI(false); 
	setProgress(100);
}

    function renderSuggestRows(rows, label){
      const tb=byId('suggestTable'); const status=byId('suggestStatus');
      status.textContent = `Top 10 — ${label}`;
      tb.innerHTML='';
      for(const r of rows.slice(0,10)){
        const tr=document.createElement('tr');
        tr.innerHTML = `
          <td class="mono">${r.word.toUpperCase()}</td>
          <td>${isFinite(r.esteps)? r.esteps.toFixed(3) : '—'}</td>
          <td>${r.entropy?.toFixed(3) ?? '—'}</td>
          <td>${r.expected?.toFixed(1) ?? '—'}</td>
          <td>${r.maxBucket ?? '—'}</td>
        `;
        tb.appendChild(tr);
      }
    }

    /* ===== Mode wiring (Hard ↔ Pool) ===== */
    function syncModeControls(){
      const hard = byId('hardMode').checked;
      byId('poolSelect').disabled = hard;
      byId('modeNote').textContent = hard
        ? 'Hard Mode ON → guess only from candidates.'
        : 'Hard Mode OFF → guess from (candidates + selected Pool).';
    }

    /* ===== Wire events ===== */
    function wire(){
      buildKeyboard(byId('gInc'),'gInc');
      buildKeyboard(byId('gExc'),'gExc');
      buildKeyboard(byId('pInc'),'pInc');
      buildKeyboard(byId('pExc'),'pExc');
      renderTabs(); refresh();

      byId('searchBox').oninput=e=>{
        state.search=e.target.value;
        state.searchTester=buildSearchTester(state.search);
        apply();
      };

      byId('clearAll').onclick=()=>{
        state.globalInclude.clear(); state.globalExclude.clear();
        for(let i=0;i<5;i++){ state.pos[i].include.clear(); state.pos[i].exclude.clear(); }
        state.search=''; state.searchTester=null; byId('searchBox').value='';
        refresh(); apply();
      };

      const f=byId('fileInput');
      byId('chooseFileBtn').onclick=()=>f.click();
      f.onchange=async()=>{
        const file=f.files?.[0]; if(!file) return;
        try{
          const t=await file.text(); const w=parseWordsFromCsvText(t);
          if(!w.length) throw new Error('empty'); loadWordsFromArray(w);
        }catch(e){ alert('Load failed: '+e.message); }
        f.value='';
      };

      byId('use2315').onclick=()=>loadCsvFile('wordle_solutions_2315.csv');
      byId('use3200').onclick=()=>loadCsvFile('wordle_solutions_3200.csv');
      byId('use14855').onclick=()=>loadCsvFile('wordle_solutions_14855.csv');

      byId('suggestFast').onclick=()=>{ suggestFast(); };
      byId('suggestExact').onclick=()=>{ suggestExact(); };
      byId('resetSuggest').onclick=resetSuggestions;
      byId('stopBtn').onclick=()=>{ state.cancel=true; byId('suggestStatus').textContent+=' (stopping…)'; };

      byId('hardMode').onchange=syncModeControls;
      byId('poolSelect').onchange=()=>{}; // no-op
      syncModeControls();

      window.onkeydown=e=>{
        if(document.activeElement===byId('searchBox')) return;
        const k=e.key, l=k.toLowerCase();
        if(l>='1'&&l<='5'){ state.activePos=Number(l)-1; refresh(); return; }
        if(k==='/'){ e.preventDefault(); byId('searchBox').focus(); return; }
        if(k==='`'){ toggleTheme(); return; }
        if(!/^[a-z]$/i.test(l)) return;
        if(e.ctrlKey||e.metaKey) toggle(state.pos[state.activePos].exclude,state.pos[state.activePos].include,l);
        else if(e.altKey)       toggle(state.globalExclude,state.globalInclude,l);
        else if(e.shiftKey)     toggle(state.pos[state.activePos].include,state.pos[state.activePos].exclude,l);
        else                    toggle(state.globalInclude,state.globalExclude,l);
        refresh(); apply();
      };
    }

    /* ===== Boot ===== */
    (async function(){
      wire();
      // Load 2315 as default current list and as base
      try{
        const base = await fetchCsv('wordle_solutions_2315.csv');
        state.base2315 = base.slice();
        loadWordsFromArray(base);
      }catch(e){
        console.error(e);
      }
    })();
  </script>

<script>
// === Analyze Word Logic ===
(function(){
  function getCandidates(){
    try{
      if (window.state && Array.isArray(window.state.filtered) && window.state.filtered.length){
        return window.state.filtered.slice();
      }
      if (window.state && Array.isArray(window.state.all) && window.state.all.length){
        return window.state.all.slice();
      }
    }catch(e){}
    var lis = Array.from(document.querySelectorAll('#words li'));
    if(lis.length) return lis.map(li=>li.textContent.trim().toLowerCase()).filter(w=>/^[a-z]{5}$/.test(w));
    return [];
  }

  function patternFor(guess, target){
    const g = guess.split(''); const t = target.split('');
    const res = Array(5).fill(0); const used = Array(5).fill(false);
    for(let i=0;i<5;i++){ if(g[i]===t[i]){ res[i]=2; used[i]=true; } }
    for(let i=0;i<5;i++){
      if(res[i]===2) continue;
      const ch = g[i];
      for(let j=0;j<5;j++){ if(!used[j] && t[j]===ch){ res[i]=1; used[j]=true; break; } }
    }
    return res.join('');
  }

  function partitionByPattern(guess, set){
    const map = new Map();
    for(const w of set){
      const p = patternFor(guess, w);
      const arr = map.get(p); if(arr) arr.push(w); else map.set(p, [w]);
    }
    return map;
  }

  function entropyOf(guess, set){
    const map = partitionByPattern(guess, set);
    const N = set.length; let H = 0; let maxb = 0; let expSize = 0;
    for(const arr of map.values()){
      const m = arr.length; const p = m / N; maxb = Math.max(maxb, m);
      if(p>0){ H += -p * Math.log2(p); }
      expSize += m*m / N;
    }
    return {entropy:H, expected:expSize, maxBucket:maxb, buckets:map};
  }



  function analyzeWord(word, set, exactThr){
    word = (word||'').toLowerCase();
    if(!/^[a-z]{5}$/.test(word)) return {error:'Please enter a 5-letter word (A–Z).'};
    if(!set || !set.length) return {error:'No candidates loaded.'};
    const fast = entropyOf(word, set);
    let esteps = null;
    try{ esteps = exactEstepsOneLookahead(word, set); }catch(e){ esteps = null; }
    return { word, esteps, entropy:fast.entropy, expected:fast.expected, maxBucket:fast.maxBucket };
  }

  function renderAnalyzeRow(result){
    const tbody = document.getElementById('analyzeTable');
    if(!tbody) return;
    tbody.innerHTML = '';
    if(result.error){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 5; td.textContent = result.error;
      tr.appendChild(td); tbody.appendChild(tr); return;
    }
    const tr = document.createElement('tr');
    const fmt = (x)=> (x==null? '—' : (Math.round(x*1000)/1000));
    const cells = [
      result.word.toUpperCase(),
      (result.esteps==null? '—' : fmt(result.esteps)),
      fmt(result.entropy),
      fmt(result.expected),
      String(result.maxBucket)
    ];
    for(const v of cells){ const td=document.createElement('td'); td.textContent=v; tr.appendChild(td); }
    tbody.appendChild(tr);
  }

  function onAnalyze(){
    const thrEl = document.getElementById('exactThreshold');
    const thr = thrEl ? Math.max(5, Math.min(2315, parseInt(thrEl.value||'200',10))) : 200;
    const set = getCandidates();
    const val = (document.getElementById('analyzeInput').value||'').trim();
    renderAnalyzeRow(analyzeWord(val, set, thr));
  }

  document.addEventListener('DOMContentLoaded', function(){
    const btn = document.getElementById('analyzeBtn');
    const ipt = document.getElementById('analyzeInput');
    if(btn) btn.addEventListener('click', onAnalyze);
    if(ipt){
      ['keydown','keypress','keyup'].forEach(ev=>ipt.addEventListener(ev, e=>e.stopPropagation()));
      ipt.addEventListener('keydown', (e)=>{ if(e.key==='Enter') onAnalyze(); });
    }
  });
})();

// === Global hotkey guard: ignore when typing in inputs/textareas/contenteditable ===
(function(){
  const addGuard = (handler) => function(e){
    const t = (e.target || document.activeElement);
    const tag = (t && t.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || (t && t.isContentEditable)) return;
    return handler.call(this, e);
  };
  // Patch document keydown listeners if code uses a single handler pattern
  // If your app attaches like: document.addEventListener('keydown', fn)
  // you can rebind here by removing and re-adding. Otherwise, rely on local stopPropagation above.
})();
</script>

</body>
</html>